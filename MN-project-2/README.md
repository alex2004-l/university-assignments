# Tema 2 – Metode Numerice – README
**Temă realizată de Lache Alexandra Florentine Georgiana, 311CD**  
**Anul I, ACS – UPB, 2022 – 2023**

## Task 1
Acest task a presupus scrierea unei funcții în Octave pentru a realiza compresia unei imagini prin descompunerea redusă în valori singulare. Primind drept argument o imagine (sub forma unei matrici cu valori între 0-255) și un factor de compresie, primul pas este de a da cast `double` la matricea imagine. După aceea, pentru a aplica descompunerea în valori singulare asupra imaginii, m-am folosit de implementarea din Octave a funcției `SVD()`, obținând matricile `U`, `D`, `V`. Ulterior, am redus aceste matrici în funcție de cel de-al doilea factor al funcției, `k`, noile dimensiuni fiind `m × k`, `k × k`, respectiv `k × n`, și cu ajutorul acestora se obține imaginea comprimată. Se observă că, cu cât valoarea lui `k` este mai redusă, cu atât comprimarea este mai pregnantă, iar imaginea este mai neclară.

## Task 2
Acest task a presupus scrierea unei funcții în Octave pentru a realiza compresia unei imagini prin analiza componentelor principale, conform primului algoritm oferit. Într-o primă etapă, imaginea a trebuit să fie normalizată, scăzând din fiecare rând media valorilor aparținând acestuia. Pentru implementarea acestui aspect, m-am folosit de funcția Octave `sum()`, care însumează elementele unei matrici primite ca argument, pe care am aplicat-o pentru a afla suma fiecărui rând, iar ulterior media. Am construit apoi matricea `Z` conform descrierii, și am aflat componentele SDV cu ajutorul funcției din Octave. Mai departe, am calculat spațiul `W`, reprezentat de primele `k` coloane ale lui `V`, am calculat proiecția imaginii pe acest spațiu, `Y = W^t × photo`, și am aproximat imaginea inițială. Se observă că, cu cât valoarea lui `k` este mai redusă, cu atât comprimarea este mai pregnantă, iar imaginea este mai neclară.

## Task 3
Acest task a presupus scrierea unei funcții în Octave pentru a realiza compresia unei imagini prin analiza componentelor principale, conform celui de-al doilea algoritm oferit. Într-o primă etapă, imaginea a trebuit să fie normalizată, scăzând din fiecare rând media valorilor aparținând acestuia. Următorul pas presupune construirea matricei de covarianță, `Z`, și aflarea vectorilor și valorilor proprii asociate acestei matrice, folosind funcția `eig()`. Pentru că folosirea funcției `eig()` pentru aflarea a doi parametri duce la salvarea valorilor proprii sub formă de matrice diagonală, am folosit funcția `diag()` pentru a obține un vector cu valorile proprii. Pentru a ordona vectorii proprii în funcție de valorile proprii, m-am folosit de funcția `sort()` pentru a determina ordinea descrescătoare a acestora, ordine ce am aplicat-o asupra matricei cu vectorii proprii, `V`. Mai departe, am calculat spațiul `W`, reprezentat de primele `k` coloane ale lui `V`, am calculat proiecția imaginii pe acest spațiu, `Y = W^t × photo`, și am aproximat imaginea inițială. Se observă că, cu cât valoarea lui `k` este mai redusă, cu atât comprimarea este mai pregnantă, iar imaginea este mai neclară.

## Task 4
Acest task a presupus scrierea mai multor funcții în Octave pentru a realiza recunoașterea cifrelor scrise de mână folosind un algoritm ce are la bază PCA. Prima funcție implementată, `prepare_data()`, returnează o matrice cu imaginile de antrenament și un vector cu label-urile asociate din setul de date MNIST, după ce datele acestui set au fost încărcate folosind funcția `load()`. Funcția `visualise_image()` are rolul de a readuce o linie din matricea cu setul de date la forma ei originală, de imagine `28 x 28`, și afișarea acesteia (dacă se dorește). Funcția `magic_with_pca()` implementează pașii 2-9 ai algoritmului de predicție exact așa cum au fost specificați, returnând aproximația matricei inițiale, media coloanelor, proiecția matricei de antrenament în spațiul componentelor principale și spațiul componentelor principale. Funcția `prepare_photo()`, convertește o imagine primită ca parametru sub formă de șir, în timp ce inversează și valorile asociate culorilor (astfel, fiecare valoare `x` din matrice, se înlocuiește cu `|255 – x|`). Funcția `KNN()` implementează algoritmul k-nearest-neighbours conform algoritmului dat, calculându-se distanța dintre imaginea ce trebuie categorizată și cele din setul de date folosind norma euclidiană. După ce toate distanțele au fost calculate, cele `k` imagini cele mai apropiate din setul de date sunt cele cu cea mai mică distanță, iar predicția este determinată aplicând funcția `median()` pe label-urile acestora. Într-un final, am îmbinat aceste funcții în funcția `classifyImage()` pentru a determina predicția.

## Scor și timp de execuție
Pe laptop-ul personal, această temă obține 100/100 de puncte, aferente testelor pentru fiecare task și existenței Readme.pdf, iar timpul de rulare al checker-ului este de sub 1 min (undeva la 43s).
